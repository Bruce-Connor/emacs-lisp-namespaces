#+OPTIONS: toc:2 num:nil

*** A Namespace implementation for Emacs-Lisp

This package aims to provide a complete and robust implementation of
(C++-like) namespaces in Emacs.

This is, by far, not the first attempt at a namespace package. See
[[https://github.com/Bruce-Connor/emacs-lisp-namespaces/blob/master/Other-Packages.org][Other-Packages.org]] for a description and comparison of previous
attempts at this.

*** Why a namespace package?
Plain and simple: Emacs doesn't have namespaces, and it needs them.

Emacs takes the approach of prefixing every symbol name with the name
of the package. Which, on the surface, is a rough simplification of
how C++ handles namespaces. This successfully avoids name clashes
between packages, but it quickly leads to code that's repetitive and
annoying to write.

Below is an example from =package.el=, the word "package" is repeated
7 times in a 10-line function definition.

*=spaces=* doesn't change the overall approach, in fact, it's
completely invisible to the end-user. =spaces= simply gives /you/ (the
developer) a convenient way of writing code that adheres to this
standard.

[[file:package-example.png][file:package-example.png]]
- At runtime, the right-hand-side will create the same definitions as the left-hand-side.
- At compilation, it will create the exact same compiled file.

*** Usage

To use this in your package:

1. Remember to list =spaces= as a dependency.
2. Wrap all code that's to be namespaced inside a =(defspace NAME ...)= macro.
3. Pleasantly remove all that redundant repetition from you code!
4. If you have =;;;###autoload= comments inside your =defspace=,
   replace them with =:autoload= and add an =;;;###autoload= tag immediately
   above your =defspace=.

This last step will make sure =defspace= returns only the autoloaded
forms when it's expanded by the =make-autoloads= function.

**** Examples

*** Keywords - Customizing the behaviour
Immediately after the name of your space you may add keywords which
customize the behaviour of =defspace=.

**** =:let-vars= 
If this is present, variables defined in let forms become namespaced
(just like defvars). If this is absent, they are preserved.

For example, assuming `foo-mo' has a variable definition, the code
#+begin_src emacs-lisp
(namespace foo-
(let ((bar mo)) ...)
)
#+end_src
expands to
#+begin_src emacs-lisp
(let ((bar foo-mo)) ...)
#+end_src
while
#+begin_src emacs-lisp
(namespace foo- :let-vars
(let ((bar mo)) ...)
)
#+end_src
expands to
#+begin_src emacs-lisp
(let ((foo-bar foo-mo)) ...)
#+end_src

*** Tested On:

**** elnode
- *Number of tests passed:* Same as before namespacing (62).
- *Reduction in code size:* Approx. 2000 characters.
**** s.el
- *Number of tests passed:* All.
- *Reduction in code size:* Approx. 1000 characters (8%).
**** dash.el
