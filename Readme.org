* Spaces
** A Namespace implementation for Emacs-Lisp

This package aims to provide a complete and robust implementation of
(C++-like) namespaces in Emacs.

This is, by far, not the first attempt at a namespace package. See
[[https://github.com/Bruce-Connor/emacs-lisp-namespaces/blob/master/Other-Packages.org][Other-Packages.org]] for a description and comparison of previous
attempts at this.

** Why a namespace package?
Plain and simple: Emacs doesn't have namespaces, and it needs them.
Read below for why that's the case.
*** The Issue
Emacs takes the approach of prefixing every symbol name with the name
of the package. Which, on the surface, is a rough simplification of
how C++ handles namespaces. This successfully avoids name clashes
between packages, but it quickly leads to code that's repetitive and
annoying to write.

Here's an example from =package.el=, the word "package" is repeated
7 times in a 10-line function definition.

#+begin_src emacs-lisp
(defun package-initialize (&optional no-activate)
  "[Doc String]"
  (interactive)
  (setq package-alist nil)
  (package-load-all-descriptors)
  (package-read-all-archive-contents)
  (unless no-activate
    (dolist (elt package-alist)
      (package-activate (car elt))))
  (setq package--initialized t))
#+end_src

*** The Solution
This package doesn't change the overall approach, in fact, it's
completely invisible to the end-user. It simply gives you (the
developer) a convenient way of writing code that adheres to this
standard.

#+begin_src emacs-lisp
(defspace package-
;; The rest of the package code goes in here as well.

(defun initialize (&optional no-activate)
  "[Doc String]"
  (interactive)
  (setq alist nil)
  (load-all-descriptors)
  (read-all-archive-contents)
  (unless no-activate
    (dolist (elt alist)
      (activate (car elt))))
  (setq -initialized t))
)
#+end_src

- At runtime, this code will create the same definitions as the previous one. 
- At compilation, it will create the exact same compiled file.

** Usage

To use this in your package:

1. Remember to list =spaces= as a dependency.
2. Wrap all code that's to be namespaced inside a =(defspace NAME ...)= macro.
3. Pleasantly remove all that redundant repetition from you code!

*** Examples

** Keywords - Customizing the behaviour
Immediately after the name of your space you may add keywords which
customize the behaviour of =defspace=.

*** =:let-vars= 
If this is present, variables defined in let forms become namespaced
(just like defvars). If this is absent, they are preserved.

For example, assuming `foo-mo' has a variable definition, the code
#+begin_src emacs-lisp
(namespace foo-
(let ((bar mo)) ...)
)
#+end_src
expands to
#+begin_src emacs-lisp
(let ((bar foo-mo)) ...)
#+end_src
while
#+begin_src emacs-lisp
(namespace foo- :let-vars
(let ((bar mo)) ...)
)
#+end_src
expands to
#+begin_src emacs-lisp
(let ((foo-bar foo-mo)) ...)
#+end_src

** Tested On:

*** elnode
- *Number of tests passed:* Same as before namespacing (62).
- *Reduction in code size:* Approx. 2000 characters.
*** s.el
- *Number of tests passed:* All.
- *Reduction in code size:* Approx. 1000 characters (8%).
*** dash.el
