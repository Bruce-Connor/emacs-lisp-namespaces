#+OPTIONS: toc:nil num:nil

* Names
/NOTE: While development on *Names* is mostly done, it is still undergoing tests. Get in touch if you'd like to test./

*Names* is designed as a practical, complete, robust, and debuggable
tool which writes your namespaces for you.

[[file:package-example.png]]
/Example usage of Names to namespace an emacs-lisp function./
*** A Namespace implementation for Emacs-Lisp

The *Names* package aims to provide an implementation of
namespaces in Emacs with four guiding principles:

- Practical :: Actually useful and easy to grasp.
- Completeness :: Support any macro/function/special-form available in
                  emacs-lisp, even the ones defined by you or a third
                  party.
- Robustness :: No-surprises, well-tested, and with clearly stated
            limitations. Yes, as complete as we aim to be,
            there will be limitations.
- Debuggable :: Support *edebug* and =eval-defun=, as well as any
                other essential tools for package developers.

See [[https://github.com/Bruce-Connor/spaces#why-a-namespace-package][Why a namespace package?]] for a description on why this is
necessary, and see [[https://github.com/Bruce-Connor/emacs-lisp-namespaces/blob/master/Other-Packages.org][Other-Packages.org]] for a description and comparison
of previous packages attempting similar things.

**** Version Compatibility
Currently, *Names* is being supported on Emacs 24.3 and 24.4. I'll
soon have a test suite setup for versions 24.2 and 24.1 as well.

** Usage

To use this in your package:

1. Remember to list =names= as a dependency.
2. Wrap all code that's to be namespaced inside a =(define-namespace NAME ...)= macro.
3. Pleasantly remove all that redundant repetition from you code!
4. When quoting function names, use #' instead of '.
5. If you have =;;;###autoload= comments inside your =define-namespace=:
   1. Replace them with =:autoload= keywords
   2. Add an =;;;###autoload= tag immediately above your =define-namespace=.

*What you need to know:* There are essentially three rules that are
applied when namespacing.
*** 1. Every definition gets namespaced
Any definitions inside =BODY= will have =NAME= prepended to the
symbol given:
#+begin_src emacs-lisp
;;;###autoload
(define-namespace foo-

(defvar bar 1 "docs")

:autoload
(defun free ()
  "DOC"
  (message "hi"))
)
#+end_src
expands to
#+begin_src emacs-lisp
(defvar foo-bar 1 "docs")

;;;###autoload
(defun foo-free ()
  "DOC"
  (message "hi"))
#+end_src

*** 2. Functions and variables are namespaced if defined
Any function calls (or variable names) get NAME prepended to them if
the symbol in question is defined as a function (or a variable,
respectively) inside the current =define-namespace= form. It doesn't
matter if the function/variable is called before actually being
defined, *Names* will find it.

In other words, a function call or variable name is /“looked up
locally”/. If it is not found, it is assumed /“global”/. You can force
a symbol to be global, by preppending it with =::=.

That is:
#+begin_src emacs-lisp
(define-namespace foo-

(defvar var infinite)

(defun infinite (x)
  (infinite x))

(cond
 ((::infinite 2) (message "Global function call"))
 ((something-else t) (message "Global function call"))
 ((infinite var) (message "Local function call."))
 (infinite (message "Variable.")))
)
#+end_src
expands to
#+begin_src emacs-lisp
(defvar foo-myvar infinite)

(defun foo-infinite (x)
  (foo-infinite x))

(cond
 ((infinite 2) (message "Global function call"))
 ((something-else t) (message "Global function call"))
 ((foo-infinite foo-var) (message "That was a function call."))
 (infinite (message "That was a variable.")))
#+end_src

Note how:
- The =infinite= symbol gets namespaced only as a function name (/not/
  when it's used as a variable), because =define-namespace= knowns
  that =foo-infinite= is not a variable.
- The symbol inside =(infinite 2)= is not namespaced, because it had
  been protected with =::=.
- =something-else= is not namespaced, because it is not a locally
  defined function, so it must be global.

*** 3. Forms not meant for evaluation are not namespaced.
Whenever a form is not meant for evaluation, it is left completely
untouched. Some examples where this applies are:
- Lists and symbols quoted with a simple quote (e.g. = 'foo=), these are regarded as data, not code;
- Any argument of a macro which doesn't get evaluated, e.g, the =KEYLIST= arguments of =cl-case=.

Some examples of the opposite:
- Symbols quoted with a function quote (e.g. =#'foo=) are regarded as
  function names, and are namespaced as explained in [[#2-functions-and-variables-are-namespaced-if-defined][item 2]]. That's
  why we recommend you always use function quotes for functions.
- Comma forms inside a backtick form (e.g. =`(nothing ,@(function)
  ,variable)=) *are* meant for evaluation and so *will* be namespaced.

*** Limitations

The main effect of [[#3-forms-not-meant-for-evaluation-are-not-namespaced][item 3]] is that the usual way of writing
=defalias= and =defvaralias= won't be namespaced. That is 
#+begin_src emacs-lisp
(define-namespace test-
(defalias 'yell #'message)
)
;; simply expands to this
(defalias 'yell #'message)
;; instead of this
(defalias 'test-yell #'message)
#+end_src

This is not considered a bug. The =SYMBOL= argument of a defalias
could just as well be an arbitrary form whose value isn't even defined
until runtime. Therefore, there is no consistent way of handling a
defalias, and we choose to just treat it as any other function call. 

Just remember to add the namespace in your defalias and defvaralias forms.

*** Case-by-case Examples
In general, =define-namespace= should work as you expect it to. But if you
need to understand why something is or isn't being namespaced, have a
look at [[https://github.com/Bruce-Connor/emacs-lisp-namespaces/blob/master/TheNittyGritty.org][TheNittyGritty.org]]

** Developer Tools
*Names* offers a series of tools to make package writing more
convenient inside a namespace. These developer facilities are on this
separate file, so the file isn't loaded on the user's computer when
your package calls =(require 'names)=.

To access them add the following line to your init file.
#+begin_src emacs-lisp
(require 'names-dev)
#+end_src

*** Edebug and eval-defun support

First and foremost, the =edebug-eval-defun= command (bound to =C-u
C-M-x=) is an essential tool for any package developer. *Names*
wouldn't be a very useful utility if it prevented you from using this
asset. 

Therefore, it provides the =names-eval-defun= command, which is
identical to =edebug-eval-defun= except it also works inside
namespaces. It will automatically be added to your
=emacs-lisp-mode-map=.

*** Font-locking 
Font-lock for =define-namespace= and =:autoload=.

*** Expansion and comparison functions
=names-compare-forms= and =names-print= offer information when
something just doesn't seem to make sense.

** Keywords - Customizing the behaviour
Immediately after the name of your space you may add keywords which
customize the behaviour of =define-namespace=. See the variable
=names--keyword-list= for a description of each possible keyword.

*** :let-vars 
If this is present, variables defined in let forms become namespaced
(just like defvars). If this is absent, they are preserved.

For example, assuming both =foo-mo= and =foo-bar= have a variable
definitions, the code
#+begin_src emacs-lisp
(define-namespace foo-
(let ((bar mo)) ...)
)
#+end_src
expands to
#+begin_src emacs-lisp
(let ((bar foo-mo)) ...)
#+end_src
while
#+begin_src emacs-lisp
(define-namespace foo- :let-vars
(let ((bar mo)) ...)
)
#+end_src
expands to
#+begin_src emacs-lisp
(let ((foo-bar foo-mo)) ...)
#+end_src

** Why a namespace package?
Plain and simple: Emacs doesn't have namespaces, and it needs them.

Nic Ferrier has a [[http://nic.ferrier.me.uk/blog/2013_06/adding-namespaces-to-elisp][great essay on the subject]]. Note that
*Names* is very different from the solution he proposes, but it does
solve the problem he had with other alternatives which left the
debugger unusable.

Emacs takes the approach of prefixing every symbol name with the name
of the package. This successfully avoids name clashes between
packages, but it quickly leads to code that's repetitive and annoying
to write. Below is an example from =package.el=, the word "/package/"
is repeated 7 times in a 10-line function.

*Names* doesn't change this overall approach. It adheres to Emacs
standards and is completely invisible to the end-user. *Names* simply
gives /you/ (the developer) a convenient way of writing code that
adheres to this standard.

[[file:package-example.png]]
/Example usage of Names to namespace an emacs-lisp function./

- At runtime, the right-hand-side will create the same definitions as the left-hand-side.
- At compilation, it will create the exact same compiled file (with no left-over reference to =names.el= functions).

*** Tested On:
*Names* is still in testing phase. If you're interested, try using it
with one of your packages and [[https://github.com/Bruce-Connor/names/issues][let me know how it goes]]. Below are the
packages which I've tested it on.

**** elnode
- *Number of ert tests passed:* Same as before namespacing (62).
- *Reduction in code size:* Approx. 2000 characters.
**** s.el
- *Number of ert tests passed:* All.
- *Reduction in code size:* Approx. 1000 characters (8%). 
1000 characters is a lot when you consider /s.el/ has the second
shortest namespace possible, =s-=.
**** dash.el
- *Number of ert tests passed:* Same as before namespacing (104).
