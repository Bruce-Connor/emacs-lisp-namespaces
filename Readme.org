#+OPTIONS: toc:nil num:nil

* Spaces
*** A Namespace implementation for Emacs-Lisp

The *Spaces* package aims to provide an implementation of
namespaces in Emacs with two guiding principles:

- Completeness :: It should support any macro/function/special-form
              available in emacs-lisp. Even the ones defined by you or
              a third party.
- Robustness :: No-surprises, well-tested, and with clearly stated
            limitations. Yes, as complete as we aim to be,
            there will be limitations.

See [[*Why%20a%20namespace%20package?][Why a namespace package?]] for a description on why this is
necessary, and see [[https://github.com/Bruce-Connor/emacs-lisp-namespaces/blob/master/Other-Packages.org][Other-Packages.org]] for a description and comparison
of previous packages attempting similar things.

*** Usage

To use this in your package:

1. Remember to list =spaces= as a dependency.
2. Wrap all code that's to be namespaced inside a =(defspace NAME ...)= macro.
3. Pleasantly remove all that redundant repetition from you code!
4. When quoting function names, use #' instead of '.
5. If you have =;;;###autoload= comments inside your =defspace=:
   1. Replace them with =:autoload= keywords
   2. Add an =;;;###autoload= tag immediately above your =defspace=.

What you need to know is: when you write 
#+begin_src emacs-lisp
(defspace NAME 
BODY
)
#+end_src
the following two rules will be applied
**** Every definition gets namespaced
Any definitions inside =BODY= will have =NAME= prepended to the
symbol given:
#+begin_src emacs-lisp
;;;###autoload
(defspace foo-

(defvar bar 1 \"docs\")

:autoload
(defun free ()
  "DOC"
  (message "hi"))

(defalias 'bird 'free)
)
#+end_src
expands to
#+begin_src emacs-lisp
(defvar foo-bar 1 \"docs\")

;;;###autoload
(defun foo-free ()
  "DOC"
  (message "hi"))

(defalias 'foo-bird 'foo-free)
#+end_src

**** Function calls and variable references are treated intelligently
Any function calls (or variable names) get NAME prepended to them if
the symbol in question has a function bind (or a variable bind,
respectively) in the namespace. That is:
#+begin_src emacs-lisp
(defspace foo-

(defvar var nil)

(defun infinite (x)
  (infinite x))

(infinite var)
(infinite infinite)
)
#+end_src
expands to
#+begin_src emacs-lisp
(defvar foo-myvar nil)

(defun foo-infinite (x)
  (foo-infinite x))

(foo-infinite foo-var)
(foo-infinite infinite)
#+end_src

Note how the =infinite= symbol gets namespaced only as a function
name, not when it's used as a variable, because =defspace= knowns that
=foo-infinite= is not a variable.

**** Case-by-case Examples
In general, =defspace= should work as you expect it to. But if you
need to understand why something is or isn't being namespaced, have a
look at [[https://github.com/Bruce-Connor/emacs-lisp-namespaces/blob/master/TheNittyGritty.org][TheNittyGritty.org]]

*** Keywords - Customizing the behaviour
Immediately after the name of your space you may add keywords which
customize the behaviour of =defspace=.

**** :let-vars 
If this is present, variables defined in let forms become namespaced
(just like defvars). If this is absent, they are preserved.

For example, assuming `foo-mo' has a variable definition, the code
#+begin_src emacs-lisp
(defspace foo-
(let ((bar mo)) ...)
)
#+end_src
expands to
#+begin_src emacs-lisp
(let ((bar foo-mo)) ...)
#+end_src
while
#+begin_src emacs-lisp
(defspace foo- :let-vars
(let ((bar mo)) ...)
)
#+end_src
expands to
#+begin_src emacs-lisp
(let ((foo-bar foo-mo)) ...)
#+end_src

*** Why a namespace package?
Plain and simple: Emacs doesn't have namespaces, and it needs them.

Emacs takes the approach of prefixing every symbol name with the name
of the package. This successfully avoids name clashes between
packages, but it quickly leads to code that's repetitive and annoying
to write.

Below is an example from =package.el=, the word "/package/" is repeated
7 times in a 10-line function definition.

*Spaces* doesn't change this overall approach, in fact, it's
completely invisible to the end-user. *Spaces* simply gives /you/ (the
developer) a convenient way of writing code that adheres to this
standard.

[[file:package-example.png]]
/Example usage of Spaces to namespace an emacs-lisp function./

- At runtime, the right-hand-side will create the same definitions as the left-hand-side.
- At compilation, it will create the exact same compiled file (with no leftover reference to =spaces.el= functions).

*** Tested On:

**** elnode
- *Number of tests passed:* Same as before namespacing (62).
- *Reduction in code size:* Approx. 2000 characters.
**** s.el
- *Number of tests passed:* All.
- *Reduction in code size:* Approx. 1000 characters (8%).
**** dash.el
